// lib/productService.ts
import { supabase } from '@/integrations/supabase/client';
import {
  addProductToBlockchain,
  checkProductOnBlockchain,
  markProductAsFakeOnBlockchain,
  isWeb3Available // Import to check MetaMask availability
} from "./blockchainService";

// Define the Product type to ensure consistency
export interface Product {
  id: string; // Supabase ID
  product_id: string; // Your unique product identifier
  name: string;
  qr_hash: string;
  is_fake: boolean;
  created_at: string;
}

// Global variable to track blockchain status for UI badge
export let blockchainStatus: 'blockchain' | 'supabase' = 'supabase';

/**
 * @dev Fetches all products from Supabase.
 * This function is primarily for displaying the product list in Admin and Manufacturer dashboards.
 * It does not involve blockchain interaction directly as product listing is handled by Supabase.
 * @returns {Promise<Product[]>} A list of products.
 */
export async function fetchProducts(): Promise<Product[]> {
  const { data, error } = await supabase
    .from('products')
    .select('*')
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching products:', error);
    return [];
  }
  return data;
}

/**
 * @dev Adds a new product. Attempts to add to blockchain first, then falls back to Supabase.
 * @param {string} productId The unique ID for the product.
 * @param {string} name The name of the product.
 * @returns {Promise<Product | null>} The added product data or null if failed.
 */
export async function addProduct(productId: string, name: string): Promise<Product | null> {
  let qrHash = ''; // This will be generated by Supabase or can be pre-generated

  // Attempt to add to blockchain first
  try {
    // Generate a simple QR hash for the product (e.g., product ID + timestamp)
    // In a real scenario, this hash might be derived differently or from the blockchain transaction hash.
    qrHash = `${productId}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;

    // Ensure MetaMask is available before trying blockchain
    if (await isWeb3Available()) {
      console.log("Attempting to add product to blockchain...");
      await addProductToBlockchain(productId, name);
      console.log("✅ Product added to blockchain.");
      blockchainStatus = 'blockchain'; // Set status for UI
    } else {
      console.warn("⚠️ MetaMask not available. Falling back to Supabase for addProduct.");
      blockchainStatus = 'supabase'; // Set status for UI
    }
  } catch (err: any) {
    console.warn("⚠️ Blockchain addProduct failed or user rejected transaction:", err.message);
    console.warn("Falling back to Supabase for addProduct.");
    blockchainStatus = 'supabase'; // Set status for UI
  }

  // Fallback or primary logic for Supabase
  const { data, error } = await supabase
    .from('products')
    .insert([{ product_id: productId, name, qr_hash: qrHash, is_fake: false }])
    .select()
    .single();

  if (error) {
    console.error('Error adding product to Supabase:', error);
    return null;
  }
  return data;
}

/**
 * @dev Verifies a product by its product ID.
 * Attempts to check on blockchain first, then falls back to Supabase.
 * @param {string} productId The product ID to verify.
 * @returns {Promise<Product | null>} The verified product data or null if not found.
 */
export async function verifyProduct(productId: string): Promise<Product | null> {
  let blockchainResult: { name: string, is_fake: boolean } | null = null;

  // Attempt to check on blockchain first
  try {
    if (await isWeb3Available()) {
      console.log("Attempting to verify product on blockchain...");
      blockchainResult = await checkProductOnBlockchain(productId);
      if (blockchainResult) {
        console.log("✅ Product verified on blockchain.");
        blockchainStatus = 'blockchain'; // Set status for UI
        // If found on blockchain, return a Product-like object
        return {
          id: productId, // Using productId as a placeholder for id
          product_id: productId,
          name: blockchainResult.name,
          qr_hash: '', // QR hash not typically returned by blockchain verify
          is_fake: blockchainResult.is_fake,
          created_at: new Date().toISOString() // Placeholder date
        };
      } else {
        console.warn("⚠️ Product not found on blockchain or blockchain check failed. Falling back to Supabase.");
        blockchainStatus = 'supabase'; // Set status for UI
      }
    } else {
      console.warn("⚠️ MetaMask not available. Falling back to Supabase for verifyProduct.");
      blockchainStatus = 'supabase'; // Set status for UI
    }
  } catch (err: any) {
    console.warn("⚠️ Blockchain verifyProduct failed:", err.message);
    console.warn("Falling back to Supabase for verifyProduct.");
    blockchainStatus = 'supabase'; // Set status for UI
  }

  // Fallback to Supabase
  const { data, error } = await supabase
    .from('products')
    .select('*')
    .eq('product_id', productId)
    .single();

  if (error) {
    console.error('Error verifying product on Supabase:', error);
    return null;
  }
  return data;
}

/**
 * @dev Verifies a product by its QR hash. Only uses Supabase as blockchain doesn't typically store QR hashes.
 * @param {string} qrHash The QR hash to verify.
 * @returns {Promise<Product | null>} The verified product data or null if not found.
 */
export async function verifyProductByQR(qrHash: string): Promise<Product | null> {
  // For QR hash verification, we will primarily rely on Supabase,
  // as the blockchain contract typically verifies by product ID, not QR hash directly.
  // The QR hash is generated by our system and points to a product ID.

  console.log("Attempting to verify product by QR hash on Supabase.");
  blockchainStatus = 'supabase'; // QR verification is primarily Supabase-backed

  const { data, error } = await supabase
    .from('products')
    .select('*')
    .eq('qr_hash', qrHash)
    .single();

  if (error) {
    console.error('Error verifying product by QR on Supabase:', error);
    return null;
  }
  return data;
}

/**
 * @dev Marks a product as fake. Attempts to mark on blockchain first, then falls back to Supabase.
 * @param {string} productId The ID of the product to mark as fake.
 * @returns {Promise<boolean>} True if successfully marked as fake, false otherwise.
 */
export async function markAsFake(productId: string): Promise<boolean> {
  // Attempt to mark as fake on blockchain first
  try {
    if (await isWeb3Available()) {
      console.log("Attempting to mark product as fake on blockchain...");
      await markProductAsFakeOnBlockchain(productId);
      console.log("✅ Product marked as fake on blockchain.");
      blockchainStatus = 'blockchain'; // Set status for UI
      // If blockchain succeeds, also update Supabase for consistency
      const { error: supabaseError } = await supabase
        .from('products')
        .update({ is_fake: true })
        .eq('product_id', productId);

      if (supabaseError) {
        console.error('Error updating Supabase after blockchain success:', supabaseError);
        // Even if Supabase update fails, blockchain record is primary for this action
        return true;
      }
      return true;
    } else {
      console.warn("⚠️ MetaMask not available. Falling back to Supabase for markAsFake.");
      blockchainStatus = 'supabase'; // Set status for UI
    }
  } catch (err: any) {
    console.warn("⚠️ Blockchain markAsFake failed or user rejected transaction:", err.message);
    console.warn("Falling back to Supabase for markAsFake.");
    blockchainStatus = 'supabase'; // Set status for UI
  }

  // Fallback to Supabase
  const { error } = await supabase
    .from('products')
    .update({ is_fake: true })
    .eq('product_id', productId);

  if (error) {
    console.error('Error marking product as fake on Supabase:', error);
    return false;
  }
  return true;
}

/**
 * @dev Fetches analytics data.
 * This function retrieves counts of real and fake products from Supabase.
 * It also aggregates recent product registration trends.
 * @returns {Promise<{ realCount: number, fakeCount: number, totalCount: number, recentProducts: any[] }>} Analytics data.
 */
export async function getAnalytics(): Promise<{ realCount: number, fakeCount: number, totalCount: number, recentProducts: any[] }> {
  const { data, error } = await supabase
    .from('products')
    .select('created_at, is_fake');

  if (error) {
    console.error('Error fetching analytics data:', error);
    return { realCount: 0, fakeCount: 0, totalCount: 0, recentProducts: [] };
  }

  const realCount = data.filter(p => !p.is_fake).length;
  const fakeCount = data.filter(p => p.is_fake).length;
  const totalCount = data.length;

  // Aggregate recent products by date
  const dailyCounts: { [key: string]: { real: number, fake: number, count: number } } = {};
  data.forEach(p => {
    const date = new Date(p.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
    if (!dailyCounts[date]) {
      dailyCounts[date] = { real: 0, fake: 0, count: 0 };
    }
    dailyCounts[date].count++;
    if (p.is_fake) {
      dailyCounts[date].fake++;
    } else {
      dailyCounts[date].real++;
    }
  });

  const recentProducts = Object.keys(dailyCounts)
    .sort((a, b) => new Date(b).getTime() - new Date(a).getTime()) // Sort by date descending
    .slice(0, 7) // Get last 7 days
    .map(date => ({ date, ...dailyCounts[date] }));

  return { realCount, fakeCount, totalCount, recentProducts };
}

